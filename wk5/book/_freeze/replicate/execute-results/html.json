{
  "hash": "f760fe8d2c309fbce309c2ef6476f998",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Replicate simulation {#sec-replicate}\n\n\n\n\n\n\n\n\n\nThis chapter shows patterns for simulating in replicate. After a basic \nreplicate simulation, we'll simulate with uncertainty and then give some \ntips on how to parallelize. \n\n\n## Basic replicate simulation\n\n### Load the model \n\nFirst, load a model and data set from which to simulate\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- mread(\"106.mrgsolve\", project = here(\"model/pk\"))\n\nmod <- update(mod, outvars = \"CL,IPRED,Y\")\n\nparam_tags(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  name   tag\n1   WT input\n2 EGFR input\n3  ALB input\n4  AGE input\n```\n\n\n:::\n:::\n\n\n\n\n### Data skeleton\n\nNow create a template data set; we'll resample from the input data from this \nmodel run.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read_csv(here(\"data/derived/analysis3.csv\"), na = '.')\n\nid <- distinct(dat, ID, WT, ALB, AGE, EGFR)\n\ncovariates <- slice_sample(id, n = 1000, replace = TRUE)\n\ncovariates <- mutate(covariates, ID = row_number())\n```\n:::\n\n\n\n\nLook at the 10 and 25 mg doses at steady state\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- crossing(\n  covariates, \n  AMT = c(10,25), \n  CMT = 1, \n  TIME = 0, \n  EVID = 1, \n  II = 24, \n  SS = 1\n)\n\ndata <- mutate(data, DOSE = AMT, ID = row_number())\n```\n:::\n\n\n\n\n\n__Remember to check the names in your data set__\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_data_names(data, mod)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFound all expected parameter names in `data`.\n```\n\n\n:::\n:::\n\n\n\n\n\n### Set up simulation\n\nI prefer to create a function that executes a single simulation replicate. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- function(i, model, data) {\n  mrgsim(\n    model,\n    data = data, \n    recover = \"WT,DOSE\",\n    output = \"df\", \n    obsonly = TRUE, \n    end = 24, \n    add = seq(0, 2, 0.1),\n    recsort = 3\n  ) %>% mutate(irep = i)\n}\n```\n:::\n\n\n\n\nNote in this function\n\n- The first argument is the current simulation replicate\n- We also pass in the data and the model object\n- We bring `WT` and `DOSE` into the simulated output\n- Output is data.frame; we don't get any benefit from the `mrgsims` object\n- We `mutate()` the simulated output so we can track it later\n\n\nThen try your function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim(2, mod, data) %>% filter(TIME %in% c(0,24)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID TIME       CL     IPRED         Y    WT DOSE irep\n1  1    0 4.145285  50.60451  63.50874 72.53   10    2\n2  1   24 4.145285  50.60451  36.33340 72.53   10    2\n3  2    0 2.124093 370.72296 369.87872 72.53   25    2\n4  2   24 2.124093 370.72296 348.49494 72.53   25    2\n5  3    0 3.884892  69.18339  48.38359 68.31   10    2\n6  3   24 3.884892  69.18339  57.88598 68.31   10    2\n```\n\n\n:::\n:::\n\n\n\n\n\nNow, call `lapply()` a simulate the desired number of replicates, setting the \nseed first to ensure reproducibility\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsim <- 10\n\nset.seed(98765)\nout <- lapply(1:nsim, sim, mod, data) %>% bind_rows()\n```\n:::\n\n\n\n\nNow we have 10 replicates of our data skeleton\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(out, irep, DOSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   irep DOSE     n\n1     1   10 43000\n2     1   25 43000\n3     2   10 43000\n4     2   25 43000\n5     3   10 43000\n6     3   25 43000\n7     4   10 43000\n8     4   25 43000\n9     5   10 43000\n10    5   25 43000\n11    6   10 43000\n12    6   25 43000\n13    7   10 43000\n14    7   25 43000\n15    8   10 43000\n16    8   25 43000\n17    9   10 43000\n18    9   25 43000\n19   10   10 43000\n20   10   25 43000\n```\n\n\n:::\n:::\n\n\n\n\nThe median pre-dose concentration at steady state is\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumm <- \n  out %>% \n  filter(TIME==24) %>% \n  group_by(irep,DOSE) %>% \n  summarise(Median = median(IPRED), .groups = \"drop\")\n\nhead(summ)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n   irep  DOSE Median\n  <int> <dbl>  <dbl>\n1     1    10   82.8\n2     1    25  210. \n3     2    10   84.5\n4     2    25  207. \n5     3    10   86.1\n6     3    25  209. \n```\n\n\n:::\n:::\n\n\n\n\n\n## Simulate with uncertainty\n\n### Load uncertainty estimates\n\nWe have bootstrap parameter estimates for this model here\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot <- read_csv(here(\"data/boot-106.csv\"))\nboot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000 × 16\n   run   THETA1 THETA2 THETA3 THETA4 THETA5 THETA6   THETA7 THETA8 `OMEGA(1,1)`\n   <chr>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>    <dbl>  <dbl>        <dbl>\n 1 001    0.494   4.19   1.20   4.20   1.24  0.488 -0.0615   0.377        0.293\n 2 002    0.405   4.07   1.14   4.23   1.32  0.536 -0.103    0.517        0.241\n 3 003    0.500   4.09   1.15   4.21   1.27  0.413 -0.0752   0.523        0.184\n 4 004    0.578   4.16   1.20   4.18   1.30  0.518 -0.0502   0.418        0.270\n 5 005    0.499   4.14   1.16   4.25   1.22  0.436 -0.0686   0.394        0.261\n 6 006    0.556   4.15   1.17   4.19   1.27  0.524 -0.0143   0.365        0.230\n 7 007    0.352   4.05   1.13   4.21   1.35  0.510 -0.0225   0.439        0.257\n 8 008    0.385   4.11   1.18   4.23   1.30  0.483 -0.0354   0.351        0.182\n 9 009    0.512   4.18   1.22   4.16   1.16  0.501  0.00906  0.493        0.283\n10 010    0.506   4.17   1.22   4.19   1.26  0.451 -0.0736   0.299        0.257\n# ℹ 990 more rows\n# ℹ 6 more variables: `OMEGA(2,1)` <dbl>, `OMEGA(2,2)` <dbl>,\n#   `OMEGA(3,1)` <dbl>, `OMEGA(3,2)` <dbl>, `OMEGA(3,3)` <dbl>,\n#   `SIGMA(1,1)` <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nWe have 1000 bootstrap replicates for `THETA`, `OMEGA` and `SIGMA`.\n\n\nLet's separate things. Just select columns for `THETA`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthetas <- select(boot, contains(\"THETA\"))\n```\n:::\n\n\n\n\nFor `OMEGA` and `SIGMA`, we have to turn these data into matrices. We do \nthis with `as_bmat()`. \n\nThe second argument is a regular expression for selecting columns from which \nto make the matrix.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nomegas <- as_bmat(boot, \"OMEGA\")\nsigmas <- as_bmat(boot, \"SIGMA\")\n```\n:::\n\n\n\n\n\nNow, `omegas` is a list with length equal to the number of rows in `boot`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(omegas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(omegas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n:::\n\n\n\n\nEach position in `omegas` is another `OMEGA` matrix\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nomegas[[10]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]      [,3]\n[1,] 0.2572420 0.0778079 0.1506750\n[2,] 0.0778079 0.0896459 0.0796598\n[3,] 0.1506750 0.0796598 0.1248070\n```\n\n\n:::\n:::\n\n\n\n\nSimilar for `sigmas`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsigmas[[100]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]\n[1,] 0.0389401\n```\n\n\n:::\n:::\n\n\n\n\n### Simulation function to use with bootstrap estimates\n\nNow, we do three update steps to update the model object with the ith set of \nbootstrap estimates. \n\n- `param()` to update `THETA`s\n- `omat()` to update `OMEGA`\n- `smat()` to update `SIGMA`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimu <- function(i, model, data, thetas, omegas, sigmas) {\n  \n  model <- param(model, slice(thetas, i))\n  model <- omat(model, omegas[[i]])\n  model <- smat(model, sigmas[[i]])\n  \n  mrgsim(\n    model,\n    data = data, \n    recover = \"WT,DOSE\",\n    output = \"df\", \n    obsonly = TRUE, \n    end = 24, \n    add = seq(0, 2, 0.1),\n    recsort = 3\n  ) %>% mutate(irep = i)\n}\n```\n:::\n\n\n\n\n\nAgain, it's a good idea to test this out\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimu(23, mod, data, thetas, omegas, sigmas) %>% as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 86,000 × 8\n      ID  TIME    CL IPRED     Y    WT  DOSE  irep\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1   0    2.08  146.  147.  72.5    10    23\n 2     1   0.1  2.08  159.  178.  72.5    10    23\n 3     1   0.2  2.08  170.  121.  72.5    10    23\n 4     1   0.3  2.08  181.  203.  72.5    10    23\n 5     1   0.4  2.08  190.  166.  72.5    10    23\n 6     1   0.5  2.08  199.  246.  72.5    10    23\n 7     1   0.6  2.08  207.  136.  72.5    10    23\n 8     1   0.7  2.08  215.  256.  72.5    10    23\n 9     1   0.8  2.08  221.  126.  72.5    10    23\n10     1   0.9  2.08  227.  253.  72.5    10    23\n# ℹ 85,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nJust like before, we can simulate with lapply\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsim <- 10\n\nset.seed(98765)\noutu <- lapply(1:nsim, simu, mod, data, thetas, omegas, sigmas) %>% bind_rows()\n```\n:::\n\n\n\n\nNow we have 10 replicates of our data skeleton\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(outu, irep, DOSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   irep DOSE     n\n1     1   10 43000\n2     1   25 43000\n3     2   10 43000\n4     2   25 43000\n5     3   10 43000\n6     3   25 43000\n7     4   10 43000\n8     4   25 43000\n9     5   10 43000\n10    5   25 43000\n11    6   10 43000\n12    6   25 43000\n13    7   10 43000\n14    7   25 43000\n15    8   10 43000\n16    8   25 43000\n17    9   10 43000\n18    9   25 43000\n19   10   10 43000\n20   10   25 43000\n```\n\n\n:::\n:::\n\n\n\n\n## Parallelization\n\nReplicate simulations might start to take a long time to complete. If so, you \ncan easily parallelize these simulations. \n\nWe recommend using the `future.apply` package, which is built on top of \n`future`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(future.apply)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: future\n```\n\n\n:::\n:::\n\n\n\n\nThis package will give us a function (`future_lapply`) that works just like \n`lapply`, but it will send each replicate to different cores on your computer, \nrunning multiple replicates at a time rather than sequentially. \n\nYou have to tell `future` what evaluation strategy you want to use. \n\nIf you are running on a `unix-alike` system, I recommend the `multicore` plan. \nThis creates workers from a _fork_  of your current R session. The performance\ntends to be a little better than `multisession`. \n\nIf you are running on a `Windows` system, you must use `multisession` \nparallelization. This strategy starts new R processes for running the jobs. \n\n\nWe tell future that we want 3 workers for this simulation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(future.fork.enable = TRUE)\nplan(multicore, workers = 3L)\n```\n:::\n\n\n\n\nNow, we can call `simu()` in parallel\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- future_lapply(\n  1:10, \n  simu, mod, data, thetas, omegas, sigmas, \n  future.seed = TRUE\n) %>% bind_rows()\n```\n:::\n\n\n\n\nYou will not see any benefit from parallelization with this few replicates. We\ncan try to increase the size of the problem to see if we can see a difference.\n\nTo simulate with `multisession`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 3L)\n\nout <- future_lapply(\n  1:10, \n  simu, mod, data, thetas, omegas, sigmas, \n  future.seed = TRUE\n) %>% bind_rows()\n```\n:::\n\n\n\n\nYou will experience a small lag when calling `plan(multisession)`; this lag is \nfrom the time required to start up the new R processes. \n\nI also like the `future.callr` package when simulations get large and overhead\nisn't that big of a deal \n<https://cran.r-project.org/web/packages/future.callr/index.html>\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}