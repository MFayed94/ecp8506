{
  "hash": "294f5084e1bc766eaf619418b9df0973",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Model specification 2 {#sec-specification-2}\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we'll keep going with model specification. This is the second\nchapter on model specification. See @sec-specification-1 for the introductory\nmaterial.\n\n## Covariate model\n\nLike NONMEM, we can use `$PK` (or `$MAIN`) to code the covariate model, \nrandom effects, F, D, R, and ALAG, and initialize compartments. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PK\n\ndouble CL = TVCL * pow(WT/70, 0.75) * exp(ETA(1));\n```\n:::\n\n\n\n\n- Any valid `c++` code is allowed\n- Each line (statement) should end in semi-colon `;`\n\n\n## C++ examples\n\n\n\n\n::: {.cell}\n\n```{.c .cell-code}\nif(a == 2) b = 2;\nif(b <= 2) {\n  c=3;\n} else {\n  c=4;\n}\nd = a==2 ? 50 : 100;\ndouble d = pow(base,exponent);\ndouble e = exp(3);\ndouble f = fabs(-4);\ndouble g = sqrt(5);\ndouble h = log(6);\ndouble i = log10(7);\ndouble j = floor(4.2);\ndouble k = ceil(4.2);\n```\n:::\n\n\n\n\nBe careful of integer division\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble result = 1/2; # 0\n```\n:::\n\n\n\n\nHere, `result` will evaluate to `0`.\n\nGood practice to put `.0` behind whole numbers. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble result = 1.0/2.0; # 0.5\n```\n:::\n\n\n\n\nLots of help on the web\nhttp://en.cppreference.com/w/cpp/numeric/math/tgamma\n\n\n## Random effects\n\nThere are times when you _will_ need to code this manually. When estimating\nwith NONMEM and simulating with `mrgsolve`, these matrices will \nfrequently be imported automatically via `$NMXML`.\n\n### Omega / ETA\n\n**Diagonal matrix**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$OMEGA\n0.1 0.2 0.3\n```\n:::\n\n\n\n\nThis is a 3x3 matrix with 0.1, 0.2, and 0.3 on the diagonal.\n\n**Block matrix**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$OMEGA @block\n0.1 0.002 0.3\n```\n:::\n\n\n\n\nThis is a 2x2 matrix matrix with 0.1 and 0.3 on the diagonal. Sometimes it's \neasier to see when we code it like this\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$OMEGA @block\n0.1 \n0.002 0.3\n```\n:::\n\n\n\n\nRandom effects simulated from OMEGA are referred to with `ETA(n)`.\n\n### Sigma / EPS\n\nWorks just like Omega / ETA, but use `$SIGMA` and `EPS(n)`.\n\nFor sigma-like theta, code it just as you would in NONMEM. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PARAM THETA12 = 0.025\n\n$SIGMA 1\n\n$ERROR\ndouble W = sqrt(THETA12);\nY = (CENT/V) + W*EPS(1);\n```\n:::\n\n\n\n\nThere is no `FIX` in `mrgsolve`; everything in OMEGA and SIGMA is always fixed. \n\n## Import estimates from NONMEM\n\n- Use `$NMEXT` or `$NMXML`\n  - `$NMEXT` reads from the `.ext` file\n    - Can be faster\n    - Doesn't retain `$OMEGA` and `$SIGMA` structure\n  - `$NMXML` reads from the `.xml` file\n    - Can be slower\n    - Does retain `$OMEGA` and `$SIGMA` structure\n\nThis is the safest way to call\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$NMXML\npath = \"../nonmem/106/106.xml\"\nroot = \"cppfile\"\n```\n:::\n\n\n\n\nYou might be able to use this `run`/`project` approach as well\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$NMXML \nrun = 1006\nproject = \"../sim/\"\nroot = \"cppfile\"\n```\n:::\n\n\n\n\n## Models in closed form\n\n`mrgsolve` will solve one- and two-compartment models with first order\ninput in closed form. This usually results in substantial speed up. \nUse `$PKMODEL`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PKMODEL cmt = \"GUT,CENT\", depot = TRUE\n```\n:::\n\n\n\n\nCertain symbols are required to be defined depending on the model. `mrgsolve`\nmodels are always parameterized in terms of clearances and volumes except\nfor absorption, which is in terms of rate constant. \n\n- `CL / V`\n- `CL / V / KA`\n- `CL / V2 / Q / V3`\n- `CL / V2 / Q / V3 / KA`\n\nThese can be defined as a parameter or a derived quantity in `$PK`.\n\nCompartment names are user-choice; the only thing mrgsolve cares about is the \nnumber of compartments.\n\n## Plugins\n\n### autodec\n\nHistorically, you have had to _declare_ the type of any new variable you \nwant to create. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PK\ndouble KE = CL/V;\n```\n:::\n\n\n\n\nFor most models, the numeric variables you declare are likely to be floating\npoint numbers ... with type `double`. \n\nWe created a plugin that tells `mrgsolve` to look for new variables and \ndeclare them for you. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PLUGIN autodec\n\n$PK\nKE = CL/V;\n```\n:::\n\n\n\n\n### nm-vars\n\n\n`mrgsolve` historically used\n\n- `CENT`\n- `dxdt_CENT`\n- `F_CENT`\n- `D_CENT`\n\netc. When we started `mrgsolve`, this was a really nice feature because you \ndidn't have to think about compartment _numbers_. However, this made\ntranslation of the model more difficult.\n\nWhen you invoke the `nm-vars` plugin, you can write in a syntax that is much \nmore like NONMEM.\n\nFor example\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PK\nF2 = THETA(3);\n\nALAG2 = EXP(THETA(4));\n\n$DES\nDADT(1) = - KA * A(1);\n```\n:::\n\n\n\n\n\nOther convenience syntax \n\n- `LOG()` and `log()`\n- `EXP()` and `exp()`\n- `SQRT()` and `sqrt()`\n\nRegardless of whether you have `nm-vars` invoked or not, you can still use\n`THETA(n)` to refer to parameter `THETAn`.\n\n\nTry the `nm-like` model in the model library for an example. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"nm-like\")\n\nmod@code\n```\n:::\n\n\n\n\n### Rcpp (random numbers)\n\nThis gives you functions and data structures that you're used to using in R, \nbut they work in `c++`. \n\nThe main use for this is random number generation. Any d/q/p/r function \nin R will be available; arguments are the same, but omit `n` (you always \nget just one draw when calling from `c++`.\n\nFor a draw from U(0,1)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n$PLUGIN Rcpp\n\n$ERROR\ndouble u = R::runif(0, 1);\n```\n:::\n\n\n\n\nNote: this will slightly increase compile time.\n\n## Other blocks\n\n- Use `$SETUP` to configure the model object on load\n  - For example, set the simulation end time\n- Use `$ENV` to define a set of R objects that might be evaluated in other \n  model blocks\n- Use `$PRED` for other closed form models\n- Use `$PREAMBLE` for code that gets run once at the start of a problem \n  `NEWIND==0`\n- Use `$GLOBAL` to define variables outside of any other block\n\n## Variables and macros\n\nThere is too much syntax to mention it all here. You will find all the \nsyntax here\n\n<https://mrgsolve.org/user-guide/specification.html#sec-variables-macros>\n\n\n## Modeled event times\n\nTo get the model to stop at any time (even if not in the data set) with \nEVID 2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble mt1 = self.mtime(1.23 + ETA(1));\n```\n:::\n\n\n\n\nTo get the model to stop at any time with user-specified EVID (e.g. 33)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nself.mevent(1.23 + ETA(1), 33);\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}