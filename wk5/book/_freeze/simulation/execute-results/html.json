{
  "hash": "efa27d1449ca37b9c1c9718818416f30",
  "result": {
    "engine": "knitr",
    "markdown": "# Simulation and outputs\n\n\n\n\n\n\n\n\n\nThis chapter discusses\n\n- Simulation from a model object\n- Dealing with simulated output\n\n\n## `mrgsim()`\n\nUse the `mrgsim()` function to actually run the simulation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"pk1\") %>% ev(amt = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmod %>% mrgsim() %>% plot()\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n### Update\n\nThe `mrgsim()` signature contains `...` which are passed to `update()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod %>% mrgsim(outvars = \"CP\", end = 72, delta = 0.1) %>% plot()\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n### Options\n\nThere are some options that can _only_ be set when you call `mrgsim(). These\nare function arguments. You can see them at `?mrgsim`\n\n- `carry_out`: numeric data columns to _copy_ into the simulated output\n- `recover`: like `carry_out` but works with any type\n- `output`: pass `\"df\"` to get output as a regular data frame\n- `obsonly`: don't return dosing records in the simulated output\n- `etasrc`: should ETAs be simulated? or scraped from the data set\n- `recsort`: how doses and observations having the same time are ordered\n- `tad`: insert time after dose into the output\n- `ss_n` and `ss_fixed`: settings for finding steady state\n- `nocb`: next observation carry backward; set to `FALSE` for locf\n\n\nAbout steady state: <https://mrgsolve.org/user-guide/steady-state.html>\n\n\n### Variants\n\n__Inputs__\n\nThere are `mrgsim()` variants which are specific to the types of inputs\n\n- `mrgsim_e()` - just an event object\n- `mrgsim_d()` - just a data set\n- `mrgsim_ei()` - event + idata set\n- `mrgsim_di()` - data set + idata set\n- `mrgsim_i()` - just idata set\n\n\n__Outputs__\n\nYou can also call `mrgsim_df()`, which is a wrapper for `mrgsim()` that \nalways returns a data frame. \n\n\n__Quick__\n\nCall `mrgsim_q()` for a quick turnaround simulation, with minimal overhead \n(and features). Only really useful when you are simulating repeatedly ... \nlike when estimating parameters or doing optimal design.\n\n\n## Simulated output\n\n`mrgsim()` returns an object with class `mrgsims`; it's a data frame with some \nextra features.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- mrgsim(mod)\n\nclass(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mrgsims\"\nattr(,\"package\")\n[1] \"mrgsolve\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID time         EV     CENT       CP\n1  1    0   0.000000  0.00000 0.000000\n2  1    0 100.000000  0.00000 0.000000\n3  1    1  36.787944 61.40526 3.070263\n4  1    2  13.533528 81.00022 4.050011\n5  1    3   4.978707 85.36010 4.268005\n6  1    4   1.831564 84.25422 4.212711\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       ID         time             EV                 CENT      \n Min.   :1   Min.   : 0.00   Min.   :  0.00000   Min.   : 0.00  \n 1st Qu.:1   1st Qu.: 5.25   1st Qu.:  0.00000   1st Qu.:39.22  \n Median :1   Median :11.50   Median :  0.00042   Median :53.61  \n Mean   :1   Mean   :11.54   Mean   :  6.08453   Mean   :52.82  \n 3rd Qu.:1   3rd Qu.:17.75   3rd Qu.:  0.20870   3rd Qu.:69.67  \n Max.   :1   Max.   :24.00   Max.   :100.00000   Max.   :85.36  \n       CP       \n Min.   :0.000  \n 1st Qu.:1.961  \n Median :2.681  \n Mean   :2.641  \n 3rd Qu.:3.483  \n Max.   :4.268  \n```\n\n\n:::\n:::\n\n\n\n\n### Output scope\n\n- First column is always `ID`\n- Second column is always `time`\n\nBy default, you get simulated values in all compartments and for every \nderived output _at every_ time\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID time         EV     CENT       CP\n1  1    0   0.000000  0.00000 0.000000\n2  1    0 100.000000  0.00000 0.000000\n3  1    1  36.787944 61.40526 3.070263\n4  1    2  13.533528 81.00022 4.050011\n5  1    3   4.978707 85.36010 4.268005\n6  1    4   1.831564 84.25422 4.212711\n```\n\n\n:::\n:::\n\n\n\n\n- `EV` and `CENT` are compartments\n- `CP` is a derived variable (`CENT/V`)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutvars(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$cmt\n[1] \"EV\"   \"CENT\"\n\n$capture\n[1] \"CP\"\n```\n\n\n:::\n:::\n\n\n\n\nYou can control which compartments and derived outputs are returned. \n\nRequest specific outputs at simulation time\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod %>% \n  update(outvars = \"CP\") %>% \n  mrgsim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel:  pk1 \nDim:    26 x 3 \nTime:   0 to 24 \nID:     1 \n    ID time    CP\n1:   1    0 0.000\n2:   1    0 0.000\n3:   1    1 3.070\n4:   1    2 4.050\n5:   1    3 4.268\n6:   1    4 4.213\n7:   1    5 4.063\n8:   1    6 3.886\n```\n\n\n:::\n:::\n\n\n\n\nOr make the change persistent\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod2 <- update(mod, outvars = \"CP\")\n\noutvars(mod2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$cmt\ncharacter(0)\n\n$capture\n[1] \"CP\"\n```\n\n\n:::\n:::\n\n\n\n\n### Copy inputs into output\n\nInput data items can be _copied_ into the simulated output without passing \nthrough the model code itself. \n\nFor most applications, use the `recover` argument to `mrgsim()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- expand.ev(amt = c(100,300)) %>% \n  mutate(dose = amt, arm = \"100 mg x1\", \"300 mg x1\")\n\nout <- mrgsim(mod, data, recover = \"dose, arm\", output = \"df\")\n\ncount(out, dose, arm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dose       arm  n\n1  100 100 mg x1 26\n2  300 100 mg x1 26\n```\n\n\n:::\n:::\n\n\n\n\nThis will let you copy inputs of _any type_ into the output. \n\nIf you just want to get numeric inputs into the output, use `carry_out`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- expand.ev(amt = c(100,300)) %>%  mutate(dose = amt)\n\nout <- mrgsim(mod, data, carry_out = \"dose\", output = \"df\")\n\ncount(out, dose)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dose  n\n1  100 26\n2  300 26\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Working with `mrgsims` object\n\nThe `mrgsims` object can be convenient to work with when the output is small. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"pk1\", delta = 0.1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading model from cache.\n```\n\n\n:::\n\n```{.r .cell-code}\nout <- mrgsim(mod, ev(amt = 100))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel:  pk1 \nDim:    242 x 5 \nTime:   0 to 24 \nID:     1 \n    ID time     EV   CENT     CP\n1:   1  0.0   0.00  0.000 0.0000\n2:   1  0.0 100.00  0.000 0.0000\n3:   1  0.1  90.48  9.492 0.4746\n4:   1  0.2  81.87 18.034 0.9017\n5:   1  0.3  74.08 25.715 1.2858\n6:   1  0.4  67.03 32.619 1.6309\n7:   1  0.5  60.65 38.819 1.9409\n8:   1  0.6  54.88 44.383 2.2191\n```\n\n\n:::\n:::\n\n\n\n\n\n### Plot\n\nPlot with a formula\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(out, CP ~ time)\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\nor a vector of output names\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(out, \"CENT CP\")\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n### Filter\n\nUse `filter_sims()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout2 <- filter_sims(out, time <= 5)\n\nplot(out2)\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n## Coerce output\n\nWhen output is big, these methods are less likely to be useful. \n\nIn this case, coerce outputs to data.frame or tibble\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- as.data.frame(out)\ndf <- as_tibble(out)\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n     ID  time    EV  CENT    CP\n  <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1   0     0    0    0    \n2     1   0   100    0    0    \n3     1   0.1  90.5  9.49 0.475\n4     1   0.2  81.9 18.0  0.902\n5     1   0.3  74.1 25.7  1.29 \n6     1   0.4  67.0 32.6  1.63 \n```\n\n\n:::\n:::\n\n\n\n\nOnce the output is coerced to data frame, it is like any other R data frame. \n\nRemember that you can get a data frame directly back from `mrgsim()` with \nthe `output` argument\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrgsim(mod, ev(amt = 100), output = \"df\") %>% class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nThis is what you'll want to do most of the time when doing larger simulations.\n\n\n### dplyr verbs\n\nYou can pipe simulated output directly to several dplyr verbs, for example\n`filter()` or `mutate()`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod %>% mrgsim(ev(amt = 100)) %>% mutate(rep = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 242 × 6\n      ID  time    EV  CENT    CP   rep\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1   0     0    0    0         1\n 2     1   0   100    0    0         1\n 3     1   0.1  90.5  9.49 0.475     1\n 4     1   0.2  81.9 18.0  0.902     1\n 5     1   0.3  74.1 25.7  1.29      1\n 6     1   0.4  67.0 32.6  1.63      1\n 7     1   0.5  60.7 38.8  1.94      1\n 8     1   0.6  54.9 44.4  2.22      1\n 9     1   0.7  49.7 49.4  2.47      1\n10     1   0.8  44.9 53.8  2.69      1\n# ℹ 232 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThis will first coerce the output object to a data frame and then continue\nto work on the simulated data according to the functions in the pipeline.\n\nOther verbs you can use include\n\n- `group_by()`\n- `mutate()`\n- `filter()`\n- `summarise()`\n- `select()`\n- `slice()`\n- `pull()`\n- `distinct()`\n\n## Writing very large outputs to disk\n\nSee the `paquet` package: \n\n<https://github.com/metrumresearchgroup/paquet>\n",
    "supporting": [
      "simulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}